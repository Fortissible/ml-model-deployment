# -*- coding: utf-8 -*-
"""cnn-img-classification-model-deployment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19sb3x8Nm9zokzNVlRVHPG7Yi9qTGn89k
"""

# Commented out IPython magic to ensure Python compatibility.
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.preprocessing import image
import zipfile,os,random,shutil
import numpy as np
from google.colab import files
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
# %matplotlib inline

! pip install kaggle
! mkdir ~/.kaggle
! cp kaggle.json ~/.kaggle/
! chmod 600 ~/.kaggle/kaggle.json
! kaggle datasets download grassknoted/asl-alphabet

! unzip asl-alphabet.zip

img_data_gen = ImageDataGenerator(
                    rescale=1./255,
                    rotation_range=10,
                    shear_range = 0.2,
                    fill_mode = 'nearest',
                    validation_split=0.2)

dirs = "EFGHIJKLMNOPQRSTUVWXYZ"
for dir in dirs: 
  img_label = "/content/asl_alphabet_train/asl_alphabet_train/" + dir
  !rm -r $img_label
dirs = ["del","nothing","space"]
for dir in dirs: 
  img_label = "/content/asl_alphabet_train/asl_alphabet_train/" + dir
  !rm -r $img_label

train_generator = img_data_gen.flow_from_directory(
        "/content/asl_alphabet_train/asl_alphabet_train",  # direktori data latih
        target_size=(150, 150),  # mengubah resolusi seluruh gambar menjadi 150x150 piksel
        batch_size=4,
        # karena ini merupakan masalah klasifikasi 2 kelas, gunakan class_mode = 'binary'
        class_mode='categorical',
        subset='training')
 
validation_generator = img_data_gen.flow_from_directory(
        "/content/asl_alphabet_train/asl_alphabet_train", # direktori data validasi
        target_size=(150, 150), # mengubah resolusi seluruh gambar menjadi 150x150 piksel
        batch_size=4, # karena ini merupakan masalah klasifikasi 2 kelas gunakan class_mode = 'binary'
        class_mode='categorical',
        subset='validation')

model = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(16, (3,3), activation='relu', input_shape=(150, 150, 3)),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Conv2D(128, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Conv2D(512, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.1),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dropout(0.05),
    tf.keras.layers.Dense(4, activation='softmax')
])
model.summary()

class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('accuracy')>0.85 and logs.get('val_accuracy')>0.85):
      print("\nAkurasi model untuk data latih dan validasi sudah >85% !!")
      self.model.stop_training = True
callbacks = myCallback()

model.compile(loss='categorical_crossentropy',
              optimizer=tf.optimizers.Adamax(),
              metrics=['accuracy'])

result = model.fit(
      train_generator,
      steps_per_epoch=50,  # berapa batch yang akan dieksekusi pada setiap epoch
      epochs=50, # tambahkan epochs jika akurasi model belum optimal
      validation_data=validation_generator, # menampilkan akurasi pengujian data validasi
      validation_steps=25,  # berapa batch yang akan dieksekusi pada setiap epoch
      verbose=2,
      callbacks=[callbacks])

plt.plot(result.history['accuracy'])
plt.plot(result.history['val_accuracy'])
plt.title('Model Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(['Train','Validation'], loc='lower right')
plt.show()

plt.plot(result.history['loss'])
plt.plot(result.history['val_loss'])
plt.title('Model loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train','Validation'], loc='upper right')
plt.show()

import pathlib

# Menyimpan model dalam format SavedModel
export_dir = 'saved_model/'
tf.saved_model.save(model, export_dir)
 
# Convert SavedModel menjadi vegs.tflite
converter = tf.lite.TFLiteConverter.from_saved_model(export_dir)
tflite_model = converter.convert()
 
tflite_model_file = pathlib.Path('asl_alphabets.tflite')
tflite_model_file.write_bytes(tflite_model)

test_images = ["A_test.jpg","B_test.jpg","C_test.jpg","D_test.jpg"]
test_path = "/content/asl_alphabet_test/asl_alphabet_test/"
for test_image in test_images:
 
  # predicting images
  img = image.load_img(test_path+test_image, target_size=(150,150))
 
  imgplot = plt.imshow(img)
  x = image.img_to_array(img)
  x = np.expand_dims(x, axis=0)
  images = np.vstack([x])
 
  classes = model.predict(images, batch_size=10)  
  print("predicted class for file " + test_image +" is:")
  if classes[0][0]==1:
    print('LABEL A!')
  elif classes[0][1]==1:
    print('LABEL B!')
  elif classes[0][2]==1:
    print('LABEL C!')
  else :
    print("LABEL D!")

